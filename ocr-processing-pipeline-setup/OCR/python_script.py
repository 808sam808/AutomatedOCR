#!/usr/bin/env python3
"""
OCR Watch & Classify Pipeline
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ Watches a folder for new images
â€¢ Runs OCR via Ollama (glm-ocr:q8_0)
â€¢ Classifies text via Groq LLM
â€¢ Appends results to category markdown files
â€¢ Serves a web dashboard to view results on the network
"""

import os
import sys
import time
import base64
import json
import logging
import threading
from datetime import datetime
from pathlib import Path

import requests
from flask import Flask, render_template_string, Response, jsonify
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Configuration â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

WATCH_FOLDER = os.environ.get("WATCH_FOLDER", "/app/watch_folder")
OCR_FOLDER = os.environ.get("OCR_FOLDER", "/app/OCR")
OLLAMA_URL = os.environ.get("OLLAMA_URL", "http://ollama:11434")
GROQ_API_KEY = os.environ.get("GROQ_API_KEY", "")
GROQ_MODEL = os.environ.get("GROQ_MODEL", "llama-3.3-70b-versatile")
WEB_PORT = int(os.environ.get("WEB_PORT", "8080"))
UPLOAD_STABLE_SECONDS = int(os.environ.get("UPLOAD_STABLE_SECONDS", "3"))
IMAGE_EXTENSIONS = {".jpg", ".jpeg", ".png", ".gif", ".bmp", ".webp", ".tiff", ".tif"}

CATEGORIES = ["chemistry", "religion", "math", "french", "other"]
MD_FILES = {cat: os.path.join(OCR_FOLDER, f"{cat}.md") for cat in CATEGORIES}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Logging â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S",
)
log = logging.getLogger("ocr-pipeline")

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Activity Log â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

activity_log = []          # in-memory log for web dashboard
activity_lock = threading.Lock()
MAX_LOG_ENTRIES = 200

PROCESSED_FILE = os.path.join(OCR_FOLDER, ".processed.json")
processed_set = set()


def load_processed():
    global processed_set
    if os.path.exists(PROCESSED_FILE):
        try:
            with open(PROCESSED_FILE, "r") as f:
                processed_set = set(json.load(f))
        except Exception:
            processed_set = set()


def save_processed():
    try:
        with open(PROCESSED_FILE, "w") as f:
            json.dump(list(processed_set), f)
    except Exception:
        pass


def add_log(level, message):
    entry = {
        "time": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        "level": level,
        "message": message,
    }
    with activity_lock:
        activity_log.insert(0, entry)
        if len(activity_log) > MAX_LOG_ENTRIES:
            activity_log.pop()
    log.log(getattr(logging, level.upper(), logging.INFO), message)


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Initialize MD Files â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def init_markdown_files():
    os.makedirs(OCR_FOLDER, exist_ok=True)
    os.makedirs(WATCH_FOLDER, exist_ok=True)
    for cat, path in MD_FILES.items():
        if not os.path.exists(path):
            with open(path, "w") as f:
                f.write(f"# {cat.capitalize()}\n\n")
                f.write(f"> Auto-generated by OCR Pipeline\n\n---\n\n")
            add_log("info", f"Created {cat}.md")


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Upload Detection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def wait_for_complete_upload(filepath, timeout=120):
    """Wait until the file size stabilises (upload finished)."""
    prev_size = -1
    stable_ticks = 0
    start = time.time()
    while time.time() - start < timeout:
        try:
            curr_size = os.path.getsize(filepath)
            if curr_size == prev_size and curr_size > 0:
                stable_ticks += 1
                if stable_ticks >= UPLOAD_STABLE_SECONDS:
                    return True
            else:
                stable_ticks = 0
            prev_size = curr_size
        except OSError:
            return False
        time.sleep(1)
    return False


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Ollama OCR â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def ocr_image(filepath):
    """Send image to Ollama glm-ocr for text recognition."""
    with open(filepath, "rb") as f:
        image_b64 = base64.b64encode(f.read()).decode("utf-8")

    filename = os.path.basename(filepath)
    payload = {
        "model": "glm-ocr:q8_0",
        "prompt": f"Text Recognition: {filename}",
        "images": [image_b64],
        "stream": False,
    }

    add_log("info", f"Sending {filename} to Ollama for OCRâ€¦")
    resp = requests.post(f"{OLLAMA_URL}/api/generate", json=payload, timeout=300)
    resp.raise_for_status()
    text = resp.json().get("response", "").strip()
    return text


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Groq Classification â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def classify_text(text):
    """Ask Groq to classify the extracted text into a category."""
    if not GROQ_API_KEY:
        add_log("warning", "GROQ_API_KEY not set â€“ defaulting to 'other'")
        return "other"

    system_prompt = (
        "You are a text classifier. Classify the following text into EXACTLY ONE "
        "of these categories: chemistry, religion, math, french, other.\n"
        "Rules:\n"
        "- 'chemistry' = chemistry, chemical equations, elements, reactions\n"
        "- 'religion' = theology, scripture, spiritual texts, religious studies\n"
        "- 'math' = mathematics, equations, algebra, calculus, geometry\n"
        "- 'french' = text written in French or French language exercises\n"
        "- 'other' = anything that does not clearly fit the above\n\n"
        "Respond with ONLY the single lowercase category word. Nothing else."
    )

    resp = requests.post(
        "https://api.groq.com/openai/v1/chat/completions",
        headers={
            "Authorization": f"Bearer {GROQ_API_KEY}",
            "Content-Type": "application/json",
        },
        json={
            "model": GROQ_MODEL,
            "messages": [
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": text[:4000]},   # trim to avoid token limits
            ],
            "temperature": 0,
            "max_tokens": 10,
        },
        timeout=30,
    )
    resp.raise_for_status()
    category = resp.json()["choices"][0]["message"]["content"].strip().lower()

    # Sanitise
    for cat in CATEGORIES:
        if cat in category:
            return cat
    return "other"


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Markdown Writer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def append_to_markdown(category, filename, text):
    md_path = MD_FILES[category]
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    with open(md_path, "a") as f:
        f.write(f"\n## ğŸ“„ {filename}\n\n")
        f.write(f"*Processed: {timestamp}*\n\n")
        f.write(f"```\n{text}\n```\n\n")
        f.write("---\n\n")


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Pipeline â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def process_image(filepath):
    filename = os.path.basename(filepath)

    if filename in processed_set:
        add_log("info", f"Skipping already-processed file: {filename}")
        return

    add_log("info", f"â³ Waiting for upload to finish: {filename}")
    if not wait_for_complete_upload(filepath):
        add_log("error", f"Timeout or error waiting for: {filename}")
        return

    # OCR
    try:
        text = ocr_image(filepath)
        if not text:
            add_log("warning", f"OCR returned empty text for {filename}")
            text = "(no text detected)"
        add_log("info", f"âœ… OCR done for {filename} â€” {len(text)} chars extracted")
    except Exception as e:
        add_log("error", f"OCR failed for {filename}: {e}")
        return

    # Classify
    try:
        category = classify_text(text)
        add_log("info", f"ğŸ·ï¸  Classified {filename} â†’ {category}")
    except Exception as e:
        add_log("error", f"Classification failed for {filename}: {e}")
        category = "other"

    # Save
    append_to_markdown(category, filename, text)
    processed_set.add(filename)
    save_processed()
    add_log("info", f"ğŸ’¾ Saved {filename} to {category}.md")


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Watchdog Handler â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class ImageHandler(FileSystemEventHandler):
    def on_created(self, event):
        if event.is_directory:
            return
        ext = Path(event.src_path).suffix.lower()
        if ext in IMAGE_EXTENSIONS:
            add_log("info", f"ğŸ“¥ New image detected: {os.path.basename(event.src_path)}")
            threading.Thread(
                target=process_image, args=(event.src_path,), daemon=True
            ).start()

    def on_moved(self, event):
        """Handle files that are moved/renamed into the folder (common upload pattern)."""
        if event.is_directory:
            return
        ext = Path(event.dest_path).suffix.lower()
        if ext in IMAGE_EXTENSIONS:
            add_log("info", f"ğŸ“¥ Image moved in: {os.path.basename(event.dest_path)}")
            threading.Thread(
                target=process_image, args=(event.dest_path,), daemon=True
            ).start()


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Flask Web App â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

app = Flask(__name__)

DASHBOARD_HTML = r"""
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>OCR Pipeline Dashboard</title>
<script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
<style>
  body { font-family: 'Inter', sans-serif; }
  .glass { background: rgba(255,255,255,0.05); backdrop-filter: blur(12px); border: 1px solid rgba(255,255,255,0.08); }
  .cat-card:hover { transform: translateY(-4px); box-shadow: 0 12px 40px rgba(0,0,0,0.3); }
  .cat-card { transition: all 0.3s ease; }
  .log-entry { animation: fadeIn 0.3s ease; }
  @keyframes fadeIn { from { opacity: 0; transform: translateY(-8px); } to { opacity: 1; transform: translateY(0); } }
  pre { white-space: pre-wrap; word-wrap: break-word; }
  .markdown-body h1 { font-size: 1.8rem; font-weight: 700; margin-bottom: 0.5rem; }
  .markdown-body h2 { font-size: 1.3rem; font-weight: 600; margin-top: 1.5rem; margin-bottom: 0.5rem; color: #a78bfa; }
  .markdown-body p { margin-bottom: 0.75rem; }
  .markdown-body code { background: rgba(255,255,255,0.1); padding: 2px 6px; border-radius: 4px; font-size: 0.9em; }
  .markdown-body pre { background: rgba(0,0,0,0.4); padding: 1rem; border-radius: 8px; margin: 0.75rem 0; overflow-x: auto; }
  .markdown-body pre code { background: none; padding: 0; }
  .markdown-body hr { border-color: rgba(255,255,255,0.1); margin: 1.5rem 0; }
  .markdown-body blockquote { border-left: 3px solid #a78bfa; padding-left: 1rem; color: #94a3b8; }
  .markdown-body em { color: #94a3b8; }
</style>
</head>
<body class="bg-gray-950 text-gray-100 min-h-screen">

<!-- Header -->
<header class="border-b border-gray-800 bg-gray-950/80 backdrop-blur sticky top-0 z-50">
  <div class="max-w-7xl mx-auto px-6 py-4 flex items-center justify-between">
    <div class="flex items-center gap-3">
      <div class="w-10 h-10 rounded-xl bg-gradient-to-br from-violet-500 to-indigo-600 flex items-center justify-center text-xl">ğŸ“</div>
      <div>
        <h1 class="text-xl font-bold bg-gradient-to-r from-violet-400 to-indigo-400 bg-clip-text text-transparent">OCR Pipeline</h1>
        <p class="text-xs text-gray-500">Watch Â· Extract Â· Classify Â· Store</p>
      </div>
    </div>
    <div class="flex items-center gap-3">
      <span id="statusDot" class="w-2.5 h-2.5 rounded-full bg-emerald-400 animate-pulse"></span>
      <span class="text-sm text-gray-400">Watching</span>
    </div>
  </div>
</header>

<main class="max-w-7xl mx-auto px-6 py-8">

  <!-- Category Cards -->
  <section class="mb-10">
    <h2 class="text-lg font-semibold text-gray-300 mb-4">ğŸ“‚ Categories</h2>
    <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-5 gap-4">
      {% for cat in categories %}
      <a href="/view/{{ cat }}" class="cat-card glass rounded-2xl p-5 block cursor-pointer group">
        <div class="text-3xl mb-2">
          {% if cat == 'chemistry' %}ğŸ§ª{% elif cat == 'religion' %}ğŸ•Šï¸{% elif cat == 'math' %}ğŸ“{% elif cat == 'french' %}ğŸ‡«ğŸ‡·{% else %}ğŸ“{% endif %}
        </div>
        <h3 class="font-semibold text-white group-hover:text-violet-400 capitalize transition-colors">{{ cat }}</h3>
        <p class="text-xs text-gray-500 mt-1">{{ cat }}.md</p>
        <div class="mt-3 flex gap-2">
          <span class="text-xs bg-violet-500/20 text-violet-300 px-2 py-0.5 rounded-full">View</span>
          <span class="text-xs bg-gray-700/50 text-gray-400 px-2 py-0.5 rounded-full">Raw</span>
        </div>
      </a>
      {% endfor %}
    </div>
  </section>

  <!-- Activity Log -->
  <section>
    <div class="flex items-center justify-between mb-4">
      <h2 class="text-lg font-semibold text-gray-300">ğŸ“‹ Activity Log</h2>
      <button onclick="fetchLogs()" class="text-xs bg-gray-800 hover:bg-gray-700 text-gray-300 px-3 py-1.5 rounded-lg transition-colors">â†» Refresh</button>
    </div>
    <div class="glass rounded-2xl overflow-hidden">
      <div id="logContainer" class="divide-y divide-gray-800/50 max-h-[500px] overflow-y-auto">
        <div class="p-8 text-center text-gray-600">Loading logsâ€¦</div>
      </div>
    </div>
  </section>

</main>

<script>
async function fetchLogs() {
  try {
    const res = await fetch('/api/logs');
    const logs = await res.json();
    const container = document.getElementById('logContainer');
    if (logs.length === 0) {
      container.innerHTML = '<div class="p-8 text-center text-gray-600">No activity yet. Drop images into the watch folder.</div>';
      return;
    }
    container.innerHTML = logs.map(l => {
      const colors = { info: 'text-sky-400', warning: 'text-amber-400', error: 'text-red-400' };
      const badges = { info: 'bg-sky-500/20 text-sky-300', warning: 'bg-amber-500/20 text-amber-300', error: 'bg-red-500/20 text-red-300' };
      return `<div class="log-entry flex items-start gap-3 px-5 py-3 hover:bg-white/[0.02]">
        <span class="text-xs font-mono text-gray-600 mt-0.5 shrink-0">${l.time}</span>
        <span class="text-xs px-2 py-0.5 rounded-full shrink-0 ${badges[l.level] || badges.info}">${l.level}</span>
        <span class="text-sm ${colors[l.level] || 'text-gray-300'}">${l.message}</span>
      </div>`;
    }).join('');
  } catch (e) {
    console.error('Failed to fetch logs', e);
  }
}
fetchLogs();
setInterval(fetchLogs, 5000);
</script>

</body>
</html>
"""

VIEW_HTML = r"""
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>{{ category | capitalize }} â€” OCR Pipeline</title>
<script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
<style>
  body { font-family: 'Inter', sans-serif; }
  .glass { background: rgba(255,255,255,0.05); backdrop-filter: blur(12px); border: 1px solid rgba(255,255,255,0.08); }
  pre { white-space: pre-wrap; word-wrap: break-word; }
  .md-render h1 { font-size: 1.8rem; font-weight: 700; margin-bottom: 1rem; color: #e2e8f0; }
  .md-render h2 { font-size: 1.3rem; font-weight: 600; margin-top: 2rem; margin-bottom: 0.75rem; color: #a78bfa; }
  .md-render p { margin-bottom: 0.75rem; color: #cbd5e1; line-height: 1.7; }
  .md-render code { background: rgba(255,255,255,0.1); padding: 2px 6px; border-radius: 4px; font-size: 0.9em; color: #e2e8f0; }
  .md-render pre { background: rgba(0,0,0,0.5); padding: 1rem; border-radius: 8px; margin: 1rem 0; overflow-x: auto; border: 1px solid rgba(255,255,255,0.05); }
  .md-render pre code { background: none; padding: 0; color: #a5f3fc; }
  .md-render hr { border-color: rgba(255,255,255,0.08); margin: 2rem 0; }
  .md-render blockquote { border-left: 3px solid #a78bfa; padding-left: 1rem; color: #94a3b8; margin: 1rem 0; }
  .md-render em { color: #94a3b8; }
  .md-render ul, .md-render ol { margin-left: 1.5rem; margin-bottom: 0.75rem; color: #cbd5e1; }
  .md-render li { margin-bottom: 0.25rem; }
</style>
</head>
<body class="bg-gray-950 text-gray-100 min-h-screen">

<header class="border-b border-gray-800 bg-gray-950/80 backdrop-blur sticky top-0 z-50">
  <div class="max-w-5xl mx-auto px-6 py-4 flex items-center justify-between">
    <div class="flex items-center gap-3">
      <a href="/" class="text-gray-500 hover:text-white transition-colors">â† Back</a>
      <div class="w-px h-6 bg-gray-700"></div>
      <span class="text-2xl">
        {% if category == 'chemistry' %}ğŸ§ª{% elif category == 'religion' %}ğŸ•Šï¸{% elif category == 'math' %}ğŸ“{% elif category == 'french' %}ğŸ‡«ğŸ‡·{% else %}ğŸ“{% endif %}
      </span>
      <h1 class="text-xl font-bold capitalize">{{ category }}</h1>
    </div>
    <div class="flex gap-2">
      <button onclick="toggleView()" id="toggleBtn" class="text-xs bg-gray-800 hover:bg-gray-700 text-gray-300 px-3 py-1.5 rounded-lg transition-colors">Show Raw</button>
      <a href="/raw/{{ category }}" class="text-xs bg-violet-600 hover:bg-violet-500 text-white px-3 py-1.5 rounded-lg transition-colors" download="{{ category }}.md">â¬‡ Download</a>
    </div>
  </div>
</header>

<main class="max-w-5xl mx-auto px-6 py-8">
  <div id="rendered" class="glass rounded-2xl p-8 md-render">
    {{ content | safe }}
  </div>
  <div id="raw" class="glass rounded-2xl p-8 hidden">
    <pre class="text-sm text-gray-300 font-mono">{{ raw }}</pre>
  </div>
  {% if not content or content | length < 50 %}
  <div class="mt-6 p-6 rounded-xl bg-gray-900 border border-gray-800 text-center">
    <p class="text-gray-500">No OCR entries yet in this category. Drop images into the watch folder!</p>
  </div>
  {% endif %}
</main>

<script>
let showRaw = false;
function toggleView() {
  showRaw = !showRaw;
  document.getElementById('rendered').classList.toggle('hidden', showRaw);
  document.getElementById('raw').classList.toggle('hidden', !showRaw);
  document.getElementById('toggleBtn').textContent = showRaw ? 'Show Rendered' : 'Show Raw';
}
</script>

</body>
</html>
"""


@app.route("/")
def dashboard():
    return render_template_string(DASHBOARD_HTML, categories=CATEGORIES)


@app.route("/view/<category>")
def view_category(category):
    if category not in CATEGORIES:
        return "Category not found", 404
    md_path = MD_FILES[category]
    raw = ""
    if os.path.exists(md_path):
        with open(md_path, "r") as f:
            raw = f.read()
    try:
        import markdown as md_lib
        content = md_lib.markdown(raw, extensions=["fenced_code", "tables"])
    except ImportError:
        # Fallback: basic rendering
        content = f"<pre>{raw}</pre>"
    return render_template_string(VIEW_HTML, category=category, content=content, raw=raw)


@app.route("/raw/<category>")
def raw_category(category):
    if category not in CATEGORIES:
        return "Category not found", 404
    md_path = MD_FILES[category]
    if not os.path.exists(md_path):
        return "", 200
    with open(md_path, "r") as f:
        content = f.read()
    return Response(content, mimetype="text/markdown",
                    headers={"Content-Disposition": f"attachment; filename={category}.md"})


@app.route("/api/logs")
def api_logs():
    with activity_lock:
        return jsonify(activity_log[:100])


@app.route("/api/status")
def api_status():
    return jsonify({
        "status": "running",
        "watch_folder": WATCH_FOLDER,
        "categories": CATEGORIES,
        "processed_count": len(processed_set),
        "ollama_url": OLLAMA_URL,
        "groq_model": GROQ_MODEL,
    })


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Main â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def main():
    if not GROQ_API_KEY:
        log.warning("âš ï¸  GROQ_API_KEY is not set! Classification will default to 'other'.")

    init_markdown_files()
    load_processed()

    add_log("info", f"ğŸ‘ï¸  Watching folder: {WATCH_FOLDER}")
    add_log("info", f"ğŸŒ Ollama endpoint: {OLLAMA_URL}")
    add_log("info", f"ğŸ¤– Groq model: {GROQ_MODEL}")
    add_log("info", f"ğŸ“Š Previously processed: {len(processed_set)} files")

    # Process any existing images that haven't been processed yet
    existing_images = []
    if os.path.isdir(WATCH_FOLDER):
        for fname in os.listdir(WATCH_FOLDER):
            ext = Path(fname).suffix.lower()
            if ext in IMAGE_EXTENSIONS and fname not in processed_set:
                existing_images.append(os.path.join(WATCH_FOLDER, fname))

    if existing_images:
        add_log("info", f"ğŸ“‚ Found {len(existing_images)} unprocessed existing images")
        for img_path in existing_images:
            threading.Thread(target=process_image, args=(img_path,), daemon=True).start()

    # Start watchdog
    observer = Observer()
    observer.schedule(ImageHandler(), WATCH_FOLDER, recursive=False)
    observer.start()

    add_log("info", f"ğŸš€ Dashboard available at http://0.0.0.0:{WEB_PORT}")

    try:
        app.run(host="0.0.0.0", port=WEB_PORT, debug=False, use_reloader=False)
    except KeyboardInterrupt:
        observer.stop()
    observer.join()


if __name__ == "__main__":
    main()
